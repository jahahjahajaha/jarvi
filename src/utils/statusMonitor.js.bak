const { 
    EmbedBuilder, 
    ActionRowBuilder, 
    ButtonBuilder, 
    ButtonStyle,
    StringSelectMenuBuilder,
    StringSelectMenuOptionBuilder
} = require('discord.js');
const os = require('os');
const systeminformation = require('systeminformation');
const moment = require('moment');
const config = require('../config');
const Logger = require('./logger');
const { version } = require('../../package.json');

/**
 * Enhanced Status Monitor for Bot Health
 * Provides real-time monitoring, advanced analytics, and interactive controls
 * in a dedicated Discord channel
 */
class StatusMonitor {
    constructor(client) {
        this.client = client;
        
        // Initialize configuration with defaults
        this.config = {
            // First try client config, then module config, then defaults
            ...(client.config?.monitoring || config.monitoring || {}), 
            
            // Ensure these required settings exist
            updateInterval: 3000, // 3 seconds
            recreateInterval: 900000, // 15 minutes
            
            // Ensure health check settings
            healthChecks: {
                memoryThreshold: 90,
                cpuThreshold: 90,
                playerThreshold: 1000,
                healthyEmoji: '‚úÖ',
                warningEmoji: '‚ö†Ô∏è',
                criticalEmoji: 'üî•'
            },
            
            // Default monitoring display properties
            displayMode: 'default',
            showRefreshButton: true,
            showControls: true,
            
            // Developer security settings
            developerIds: [
                ...(client.config?.ownerID ? [client.config.ownerID] : []), 
                ...(config.ownerID ? [config.ownerID] : []),
                '450889132297396225', // Default bot developer ID
            ],
            
            // Message persistence config
            persistMessage: true,
            stabilityMode: true,
            deleteOldStatusMessages: true,
            maxMessagesToDelete: 10
        };
        
        // Message instances
        this.statusMessage = null;
        this.controlsMessage = null;
        this.monitoringInterval = null;
        this.statusChannel = null;
        
        // Timing trackers
        this.lastUpdate = Date.now();
        this.startTime = Date.now();
        this.lastRestartTime = Date.now();
        
        // State flags
        this.cleanupCompleted = false;
        this.startupCleanupCompleted = false;
        this.isPaused = false;
        
        // Analytics data
        this.historicalData = {
            cpu: [],
            memory: [],
            players: [],
            users: [],
            guilds: []
        };
        this.maxHistoricalDataPoints = 20; // Store up to 20 data points for trends
        this.cmdExecutionCount = 0;
        this.errorCount = 0;
    }

    /**
     * Initialize the status monitor
     */
    async init() {
        if (!this.config.enabled) {
            console.log("[STATUS] Status monitoring is disabled in config");
            return;
        }

        try {
            // Fetch status channel
            this.statusChannel = await this.client.channels.fetch(this.config.statusChannelId).catch(() => null);
            if (!this.statusChannel) {
                console.log("[ERROR] Status channel not found! Monitoring disabled.");
                return;
            }
            
            // Update channel name to show bot is online (üî¥ -> üü¢)
            await this.updateChannelStatusIndicator();
            
            // We'll use a more careful approach to cleaning up old messages
            // Delete only enough to make room for our 2 panels
            this.controlsMessage = null;
            
            // Clean up with a limited number to avoid rate limits
            await this.cleanupStatusChannel(99);
            this.startupCleanupCompleted = true;
            
            // Reset the cleanup status
            this.cleanupCompleted = false;
            
            // Force creation of a new status message
            this.statusMessage = null;
            
            // Try to find existing status message if we want to persist it
            if (this.config.persistMessage && this.config.statusMessageId) {
                try {
                    this.statusMessage = await this.statusChannel.messages.fetch(this.config.statusMessageId);
                    console.log(`[INFO] Found existing status message: ${this.config.statusMessageId}`);
                } catch (err) {
                    console.log(`[INFO] Could not find existing status message: ${err.message}`);
                    this.statusMessage = null;
                }
            }
            
            // Try to find existing controls message if we want to persist it
            if (this.config.persistMessage && this.config.controlsMessageId) {
                try {
                    this.controlsMessage = await this.statusChannel.messages.fetch(this.config.controlsMessageId);
                    console.log(`[INFO] Found existing controls message: ${this.config.controlsMessageId}`);
                } catch (err) {
                    console.log(`[INFO] Could not find existing controls message: ${err.message}`);
                    this.controlsMessage = null;
                }
            }
            
            // Create both status message and controls message
            await this.updateStatus();
            
            // Create controls message if it doesn't exist yet
            if (!this.controlsMessage && this.config.showControls) {
                const controls = this.createInteractiveControls();
                this.controlsMessage = await this.statusChannel.send(controls);
                
                if (this.config.persistMessage) {
                    this.config.controlsMessageId = this.controlsMessage.id;
                }
                
                console.log(`[INFO] Created controls panel message at ${new Date().toISOString()}`);
            }

            // Start periodic updates
            this.startMonitoring();

            console.log("[READY] Bot status monitoring system initialized");
        } catch (error) {
            console.error(`[ERROR] Failed to initialize status monitoring: ${error.message}`);
        }
    }
    
    /**
     * Update the channel status indicator emoji (üî¥ -> üü¢)
     * Shows that the bot is online by updating channel name
     */
    async updateChannelStatusIndicator() {
        if (!this.statusChannel || !this.statusChannel.manageable) return;
        
        try {
            const currentName = this.statusChannel.name;
            
            // If the channel already has the online indicator, do nothing
            if (currentName.includes('üü¢')) {
                return;
            }
            
            // Replace offline indicator with online indicator, or add online indicator
            let newName;
            if (currentName.includes('üî¥')) {
                newName = currentName.replace('üî¥', 'üü¢');
            } else {
                // If no indicator exists, add the online indicator at the end
                newName = currentName + ' üü¢';
            }
            
            // Update channel name
            await this.statusChannel.setName(newName);
            console.log(`[INFO] Updated status channel name: ${currentName} -> ${newName}`);
        } catch (error) {
            console.error(`[ERROR] Failed to update channel status indicator: ${error.message}`);
        }
    }
    
    /**
     * Clean up the status channel by deleting all messages
     * @param {Number} limit - Maximum number of messages to delete
     */
    async cleanupStatusChannel(limit = 100) {
        try {
            if (!this.statusChannel) return;
            
            // We want to clean up every time the bot restarts, so removed the cleanupCompleted check
            // to ensure messages are always deleted
            
            console.log(`[INFO] Cleaning up status channel - deleting old messages...`);
            
            // Fetch messages (up to the limit)
            const messages = await this.statusChannel.messages.fetch({ limit });
            
            // If we have messages to delete
            if (messages.size > 0) {
                // Use bulkDelete for messages less than 14 days old
                try {
                    await this.statusChannel.bulkDelete(messages);
                    console.log(`[INFO] Bulk deleted ${messages.size} messages from status channel`);
                } catch (bulkError) {
                    // If bulk delete fails (messages older than 14 days), delete one by one
                    console.log(`[WARN] Bulk delete failed, deleting one by one: ${bulkError.message}`);
                    
                    let deleteCount = 0;
                    for (const [_, message] of messages) {
                        try {
                            await message.delete();
                            deleteCount++;
                            
                            // Add a small delay to avoid rate limits
                            await new Promise(resolve => setTimeout(resolve, 100));
                        } catch (err) {
                            // Ignore errors for individual message deletions
                        }
                    }
                    
                    if (deleteCount > 0) {
                        console.log(`[INFO] Deleted ${deleteCount} old messages one by one from status channel`);
                    }
                }
            }
            
            // We've removed the cleanupCompleted flag to ensure messages are always cleaned up
        } catch (error) {
            console.error(`[ERROR] Failed to clean up status channel: ${error.message}`);
        }
    }

    /**
     * Start periodic monitoring
     */
    startMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
        }

        // Use the configured interval (default to 3 seconds if not set)
        const interval = this.config.updateInterval || 3000;
        
        // Log the update interval for debugging
        console.log(`[INFO] Status monitor set to update every ${interval/1000} seconds`);
        
        this.monitoringInterval = setInterval(() => {
            this.updateStatus().catch(error => {
                // Only log to console
                console.error(`[ERROR] Status update error: ${error.message}`);
            });
        }, interval);
    }

    /**
     * Stop monitoring
     */
    stopMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
        }
    }

    /**
     * Update the status message
     */
    async updateStatus() {
        if (!this.statusChannel) return;

        try {
            // Get system information for health check
            const [cpuLoad, memLoad, diskLoad] = await Promise.all([
                systeminformation.currentLoad(),
                systeminformation.mem(),
                systeminformation.fsSize()
            ]);

            // Calculate health metrics
            // Use available memory calculation to exclude cache/buffers for more accurate reporting
            const actualMemoryUsed = memLoad.used - memLoad.buffcache; // Subtract buffers and cache
            const memoryUsagePercent = Math.round((actualMemoryUsed / memLoad.total) * 100);
            const cpuUsagePercent = Math.round(cpuLoad.currentLoad);
            const diskUsagePercent = Math.round((diskLoad[0].used / diskLoad[0].size) * 100);
            const playerCount = this.client.manager?.players?.size || 0;
            const guildCount = this.client.guilds.cache.size;
            const userCount = this.client.users.cache.size;
            
            // Update historical data for trend analysis
            this.updateHistoricalData({
                cpu: cpuUsagePercent,
                memory: memoryUsagePercent,
                players: playerCount,
                users: userCount,
                guilds: guildCount
            });
            
            // Calculate reliability score
            const reliabilityScore = this.calculateReliabilityScore();
            
            // Check if we need to recreate the message (based on config interval)
            // Only recreate if specified in config or if the message doesn't exist
            const shouldRecreateMessage = 
                !this.statusMessage || 
                (this.config.recreateInterval && 
                 Date.now() - this.lastUpdate > this.config.recreateInterval);
                
            // Reset cleanup flag only if we're using deletion-based recreation
            if (shouldRecreateMessage && this.config.deleteOldStatusMessages) {
                this.cleanupCompleted = false;
            }
            
            // Get uptime information
            const uptime = this.getReadableUptime();
            
            // Calculate overall health
            const overallHealth = this.calculateOverallHealth(
                memoryUsagePercent, 
                cpuUsagePercent, 
                playerCount
            );
            
            // Always use the stable GIF for beautiful effect
            const thumbnailUrl = 'https://cdn.discordapp.com/attachments/1310269100752371732/1349286890490171402/Online1.gif';
            
            // Always show positive status - client requested
            let statusMessage = '‚úÖ **All Systems Operational**';
            
            // Always show positive status indicators - client requested
            const memoryStatus = '‚úÖ';
            const cpuStatus = '‚úÖ';
            const diskStatus = '‚úÖ';
            const lavalinkStatus = '‚úÖ';
            
            // Format memory display
            const memoryFormatted = `${Math.round(actualMemoryUsed / 1024 / 1024).toLocaleString()}/${Math.round(memLoad.total / 1024 / 1024).toLocaleString()} MB`;
            
            // Determine if there are active voice connections
            const voiceConnections = this.client.manager?.players?.size || 0;
            // Always show ‚úÖ for voice status - client requested
            const voiceStatus = '‚úÖ';
            
            // Generate embedbuilder based on display mode
            let embed;
            
            // Create the appropriate embed based on display mode preference
            switch (this.displayMode) {
                case 'detailed':
                    embed = this.createAnalyticsEmbed();
                    break;
                    
                case 'minimal':
                    // Create minimal embed with just essential info
                    embed = new EmbedBuilder()
                        .setColor("#44FF44")
                        .setThumbnail(thumbnailUrl)
                        .setTitle(`${this.client.user.username} Status`)
                        .setDescription(`
                            ${statusMessage}
                            
                            **Updated:** <t:${Math.floor(Date.now() / 1000)}:R>
                            **Uptime:** ${uptime}
                            **Servers:** ${guildCount} ‚Ä¢ **Users:** ${userCount}
                            **System:** Memory ${memoryUsagePercent}% ‚Ä¢ CPU ${cpuUsagePercent}%
                        `)
                        .setFooter({ 
                            text: `Version v0.10.0 ‚Ä¢ ${moment().format('MMMM Do YYYY')}`,
                            iconURL: this.client.user.displayAvatarURL() 
                        });
                    break;
                    
                default: // 'default' mode
                    // Always use green color for status display - client requested
                    embed = new EmbedBuilder()
                        .setColor("#44FF44") // Always green
                        .setThumbnail(thumbnailUrl)
                        .setAuthor({
                            name: `${this.client.user.username} Status Dashboard`,
                            iconURL: this.client.user.displayAvatarURL({ dynamic: true })
                        })
                        .setDescription(`
                            ${statusMessage}
                            
                            <a:Save_the_date_gif:1342818099610517534> **Last Updated:** <t:${Math.floor(Date.now() / 1000)}:R>
                            <:Clock_timer:1342818097765589013> **Uptime:** ${uptime}
                        `)
                        .addFields([
                            {
                                name: "<:Jarvi_Logo:1340405392307388468> Bot Status",
                                value: [
                                    `<a:Discord_rocket:1342842402167324806> **Version:** \`v0.10.0\``,
                                    `<:Server_icon:1342864321754914836> **Servers:** \`${guildCount.toLocaleString()}\` ${this.calculateTrend('guilds')}`,
                                    `<a:Yellow_members_icon_gif:1342819050446782537> **Users:** \`${userCount.toLocaleString()}\` ${this.calculateTrend('users')}`,
                                    `${voiceStatus} **Active Players:** \`${voiceConnections}\` ${this.calculateTrend('players')}`
                                ].join('\n'),
                                inline: true
                            },
                            {
                                name: "üíª System Resources",
                                value: [
                                    `${memoryStatus} **Memory:** \`${memoryUsagePercent}%\` (${memoryFormatted}) ${this.calculateTrend('memory')}`,
                                    `${cpuStatus} **CPU:** \`${cpuUsagePercent}%\` ${this.calculateTrend('cpu')}`,
                                    `${diskStatus} **Disk:** \`${diskUsagePercent}%\``,
                                    `<:Node:1342864318721876031> **Node.js:** \`${process.version}\``
                                ].join('\n'),
                                inline: true
                            },
                            {
                                name: "üéµ Music Service Status",
                                value: [
                                    `${lavalinkStatus} **Lavalink:** \`${this.client.manager?.nodes?.filter(n => n.connected).size || 0}/${this.client.manager?.nodes?.size || 0} nodes\``,
                                    `${voiceStatus} **Voice:** \`${voiceConnections} connections\``,
                                    `üîä **Players:** \`${playerCount}\` active`
                                ].join('\n'),
                                inline: false
                            },
                            {
                                name: "‚öôÔ∏è System Health",
                                value: [
                                    `üî∞ **Reliability Score:** \`${reliabilityScore}/100\``,
                                    `üìä **System Load:** \`${this.systemLoadLevel(cpuUsagePercent)}\``,
                                    `üß† **Memory Usage:** \`${this.memoryUsageLevel(memoryUsagePercent)}\``
                                ].join('\n'),
                                inline: false
                            }
                        ])
                        .setFooter({ 
                            text: `Updates every ${Math.floor(this.config.updateInterval/1000)} seconds ‚Ä¢ ${this.isPaused ? 'PAUSED' : 'ACTIVE'} ‚Ä¢ ${moment().format('dddd, MMMM Do YYYY, h:mm:ss A')}`,
                            iconURL: this.client.user.displayAvatarURL() 
                        });
            }

            // Determine if we should create interactive controls (every 15 minutes)
            let messageContent = null;
            let components = [];
            
            if (shouldRecreateMessage) {
                // Every 15 minutes, create a new set of interactive controls
                if (this.config.showRefreshButton) {
                    // Create a new row for buttons
                    const row = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('refresh_status')
                                .setLabel('Refresh')
                                .setStyle(ButtonStyle.Primary)
                                .setEmoji('üîÑ')
                        );
                    
                    components.push(row);
                }
            }

            // Try to edit the existing status message first if it exists
            if (this.statusMessage && !shouldRecreateMessage) {
                try {
                    await this.statusMessage.edit({ 
                        embeds: [embed],
                        components: [] // No components on main status message
                    });
                    // Successful edit, update timestamp
                    this.lastUpdate = Date.now();
                } catch (err) {
                    console.log(`[INFO] Failed to edit status message (${err.message}), will recreate...`);
                    this.statusMessage = null; // Force recreation
                    // Continue to recreation logic below
                }
            }
            
            // Also try to edit the controls message if it exists
            if (this.controlsMessage) {
                try {
                    const controls = this.createInteractiveControls();
                    await this.controlsMessage.edit(controls);
                    // Log successful controls update only in debug mode to reduce log spam
                    // console.log(`[DEBUG] Successfully updated controls message`);
                } catch (err) {
                    console.log(`[INFO] Failed to edit controls message (${err.message}), will recreate...`);
                    this.controlsMessage = null; // Force recreation of controls panel
                }
            }
            
            // Create a new status message if needed (either we don't have one or edit failed)
            if (!this.statusMessage) {
                // Only clean up if configured to do so (and not in stable mode)
                // To prevent potential loss of messages, we'll clean up only when absolutely necessary
                if (this.config.deleteOldStatusMessages && !this.config.stabilityMode && !this.cleanupCompleted) {
                    console.log(`[INFO] Cleaning up status channel before creating new message...`);
                    await this.cleanupStatusChannel(99); // Clean up to make room for new messages
                    this.cleanupCompleted = true; // Mark cleanup as completed to prevent repeated cleanups
                }
                
                // Log creation
                console.log(`[INFO] Creating new status message at ${new Date().toISOString()}`);
                
                // Create a new status message
                try {
                    this.statusMessage = await this.statusChannel.send({ 
                        content: messageContent,
                        embeds: [embed],
                        components: [] // No components on main status message
                    });
                    
                    // Update timestamp for next recreation cycle
                    this.lastUpdate = Date.now();
                    
                    // Store the message ID for potential persistence
                    if (this.config.persistMessage) {
                        this.config.statusMessageId = this.statusMessage.id;
                    }
                } catch (error) {
                    console.error(`[ERROR] Failed to create status message: ${error.message}`);
                }
            }
            
            // Create a new controls message if needed and enabled
            if (!this.controlsMessage && this.config.showControls) {
                try {
                    const controls = this.createInteractiveControls();
                    this.controlsMessage = await this.statusChannel.send(controls);
                    
                    console.log(`[INFO] Created new controls message at ${new Date().toISOString()}`);
                    
                    // Store the message ID for potential persistence
                    if (this.config.persistMessage) {
                        this.config.controlsMessageId = this.controlsMessage.id;
                    }
                } catch (error) {
                    console.error(`[ERROR] Failed to create controls message: ${error.message}`);
                }
            }
        } catch (error) {
            // Only log errors to console, not to Discord
            console.error(`[ERROR] Error updating status: ${error.message}`);
        }
    }
    
    /**
     * Get text description of system load level
     * @param {Number} cpuPercent - CPU usage percentage
     * @returns {String} Load level description
     */
    systemLoadLevel(cpuPercent) {
        if (cpuPercent < 30) return 'Low';
        if (cpuPercent < 70) return 'Moderate';
        if (cpuPercent < 90) return 'High';
        return 'Critical';
    }
    
    /**
     * Get text description of memory usage level
     * @param {Number} memPercent - Memory usage percentage
     * @returns {String} Memory usage level description
     */
    memoryUsageLevel(memPercent) {
        if (memPercent < 30) return 'Low';
        if (memPercent < 70) return 'Moderate';
        if (memPercent < 90) return 'High';
        return 'Critical';
    }

    /**
     * Handle button interaction for refresh
     */
    async handleStatusInteraction(interaction) {
        // First defer the update to prevent interaction timeout
        await interaction.deferUpdate().catch(err => console.error(`[ERROR] Failed to defer update: ${err.message}`));
        
        // Custom authorization check for developer-only controls
        const isDeveloper = this.isUserDeveloper(interaction.user.id);
        
        // Record the interaction in general logs (only for developer commands)
        if (isDeveloper) {
            console.log(`[DEV] ${interaction.user.tag} (ID: ${interaction.user.id}) used monitoring control: ${interaction.customId}`);
        }
        
        if (interaction.customId === "refresh_status") {
            // Only allow refresh when monitoring is paused or the user is a developer
            if (this.isPaused || isDeveloper) {
                // Update the status
                await this.updateStatus();
                
                // Send ephemeral (hidden) confirmation message only visible to the user
                await interaction.followUp({
                    content: `‚úÖ Status has been refreshed.`,
                    ephemeral: true
                }).catch(err => {
                    console.error(`[ERROR] Failed to send refresh confirmation: ${err.message}`);
                });
                
                console.log(`[INFO] Status refreshed by ${interaction.user.tag}`);
            } else {
                // Regular users can't refresh when auto-monitoring is active
                await interaction.followUp({
                    content: `‚ÑπÔ∏è Status is already updating automatically every ${this.config.updateInterval/1000} seconds.`,
                    ephemeral: true
                }).catch(err => console.error(`[ERROR] Failed to send message: ${err.message}`));
            }
        }
        else if (interaction.customId === "toggle_monitoring") {
            // Only allow developers to toggle monitoring state
            if (!isDeveloper) {
                await interaction.followUp({
                    content: `‚ú® The bot is working perfectly! All systems are operational.`,
                    ephemeral: true
                }).catch(err => console.error(`[ERROR] Failed to send message: ${err.message}`));
                console.log(`[SECURITY] Unauthorized monitoring toggle attempt by ${interaction.user.tag}`);
                return;
            }
            
            // Toggle monitoring state
            this.isPaused = !this.isPaused;
            
            if (this.isPaused) {
                // Stop the interval
                if (this.monitoringInterval) {
                    clearInterval(this.monitoringInterval);
                    this.monitoringInterval = null;
                }
                
                await interaction.followUp({
                    content: `üõë Monitoring has been paused. Manual refresh button is now enabled.`,
                    ephemeral: true
                }).catch(err => console.error(`[ERROR] Failed to send message: ${err.message}`));
                
                console.log(`[INFO] Monitoring paused by developer ${interaction.user.tag}`);
            } else {
                // Restart the interval
                this.startMonitoring();
                
                await interaction.followUp({
                    content: `‚ñ∂Ô∏è Monitoring has been resumed. Auto-updates every ${this.config.updateInterval/1000} seconds.`,
                    ephemeral: true
                }).catch(err => console.error(`[ERROR] Failed to send message: ${err.message}`));
                
                console.log(`[INFO] Monitoring resumed by developer ${interaction.user.tag}`);
            }
            
            // Update status and controls immediately to reflect new state
            await this.updateStatus();
        }
        else if (interaction.customId === "view_analytics") {
            // Analytics view is allowed for all users
            const analyticsEmbed = this.createAnalyticsEmbed();
            
            await interaction.followUp({
                embeds: [analyticsEmbed],
                ephemeral: true
            }).catch(err => console.error(`[ERROR] Failed to send analytics: ${err.message}`));
            
            console.log(`[INFO] Analytics viewed by ${interaction.user.tag}`);
        }
        else if (interaction.customId === "status_display_mode") {
            // Only allow developers to change display mode
            if (!isDeveloper) {
                await interaction.followUp({
                    content: `‚ú® The bot is working perfectly! Status display is managed by developers.`,
                    ephemeral: true
                }).catch(err => console.error(`[ERROR] Failed to send message: ${err.message}`));
                
                console.log(`[SECURITY] Unauthorized display mode change attempt by ${interaction.user.tag}`);
                return;
            }
            
            try {
                // Get selected value
                const selectedValue = interaction.values[0];
                this.displayMode = selectedValue;
                
                await interaction.followUp({
                    content: `üîÑ Display mode changed to: ${selectedValue}`,
                    ephemeral: true
                }).catch(err => console.error(`[ERROR] Failed to send confirmation: ${err.message}`));
                
                console.log(`[INFO] Status display mode changed to ${selectedValue} by ${interaction.user.tag}`);
                
                // Update immediately to show new display mode
                await this.updateStatus();
            } catch (error) {
                console.error(`[ERROR] Failed to change display mode: ${error.message}`);
            }
        }
    }
    
    /**
     * Check if a user is a developer with elevated permissions
     * @param {String} userId - Discord user ID to check
     * @returns {Boolean} True if user is a developer
     */
    isUserDeveloper(userId) {
        // Check if user ID is in the list of developer IDs
        return this.config.developerIds && 
               this.config.developerIds.includes(userId);
    }

    /**
     * Get readable uptime string
     */
    getReadableUptime() {
        const uptime = moment.duration(Date.now() - this.startTime);
        const days = Math.floor(uptime.asDays());
        const hours = uptime.hours();
        const minutes = uptime.minutes();
        const seconds = uptime.seconds();
        
        const parts = [];
        if (days > 0) parts.push(`${days}d`);
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0) parts.push(`${minutes}m`);
        if (seconds > 0) parts.push(`${seconds}s`);
        
        return parts.join(' ');
    }

    /**
     * Get status emoji based on threshold
     */
    getStatusEmoji(value, threshold) {
        const { healthyEmoji, warningEmoji, criticalEmoji } = this.config.healthChecks;
        
        if (value < threshold * 0.7) {
            return healthyEmoji;
        } else if (value < threshold) {
            return warningEmoji;
        } else {
            return criticalEmoji;
        }
    }

    /**
     * Calculate overall health state (0-2, 0=healthy, 1=warning, 2=critical)
     */
    calculateOverallHealth(memoryUsage, cpuUsage, playerCount) {
        const { memoryThreshold, cpuThreshold, playerThreshold } = this.config.healthChecks;
        
        if (memoryUsage >= memoryThreshold || cpuUsage >= cpuThreshold || playerCount >= playerThreshold) {
            return 2; // Critical
        } else if (
            memoryUsage >= memoryThreshold * 0.7 || 
            cpuUsage >= cpuThreshold * 0.7 || 
            playerCount >= playerThreshold * 0.7
        ) {
            return 1; // Warning
        } else {
            return 0; // Healthy
        }
    }

    /**
     * Get overall status emoji based on health state
     */
    getOverallStatusEmoji(healthState) {
        const { healthyEmoji, warningEmoji, criticalEmoji } = this.config.healthChecks;
        
        switch (healthState) {
            case 0: return `${healthyEmoji} Healthy`;
            case 1: return `${warningEmoji} Warning`;
            case 2: return `${criticalEmoji} Critical`;
            default: return `${warningEmoji} Unknown`;
        }
    }

    /**
     * Get color based on health state
     */
    getHealthColor(healthState) {
        switch (healthState) {
            case 0: return "#44FF44"; // Green for healthy
            case 1: return "#FFAA00"; // Orange for warning
            case 2: return "#E87147"; // Same as config.embed.color (instead of red)
            default: return "#7289DA"; // Discord blue for unknown
        }
    }

    /**
     * Track and update historical data points for trend analysis
     * @param {Object} data - Current data points to add
     */
    updateHistoricalData(data) {
        // Add new data points to the historical dataset
        this.historicalData.cpu.push(data.cpu);
        this.historicalData.memory.push(data.memory);
        this.historicalData.players.push(data.players);
        this.historicalData.users.push(data.users);
        this.historicalData.guilds.push(data.guilds);
        
        // Trim arrays to keep only the last maxHistoricalDataPoints elements
        Object.keys(this.historicalData).forEach(key => {
            if (this.historicalData[key].length > this.maxHistoricalDataPoints) {
                this.historicalData[key] = this.historicalData[key].slice(-this.maxHistoricalDataPoints);
            }
        });
    }
    
    /**
     * Calculate trend direction based on historical data
     * @param {String} metric - The metric to analyze
     * @returns {String} Trend direction indicator (‚Üë, ‚Üì, or ‚Üí)
     */
    calculateTrend(metric) {
        const data = this.historicalData[metric];
        if (data.length < 3) return "‚Üí"; // Not enough data points
        
        const recent = data.slice(-3); // Get last 3 data points
        const first = recent[0];
        const last = recent[recent.length - 1];
        
        // Simple trend detection
        if (last > first * 1.05) return "‚Üë"; // 5% increase
        if (last < first * 0.95) return "‚Üì"; // 5% decrease
        return "‚Üí"; // Stable
    }
    
    /**
     * Generate detailed analytics embed with charts and trends
     * @returns {EmbedBuilder} Detailed analytics embed
     */
    createAnalyticsEmbed() {
        const embed = new EmbedBuilder()
            .setColor("#44FF44")
            .setTitle("üìä Detailed System Analytics")
            .setDescription("Showing current system status with trend analysis")
            .setThumbnail(this.client.user.displayAvatarURL({ dynamic: true }))
            .addFields([
                {
                    name: "üìà Resource Trends",
                    value: [
                        `**CPU Usage:** ${this.historicalData.cpu.slice(-1)[0] || 0}% ${this.calculateTrend('cpu')}`,
                        `**Memory Usage:** ${this.historicalData.memory.slice(-1)[0] || 0}% ${this.calculateTrend('memory')}`,
                        `**Players:** ${this.historicalData.players.slice(-1)[0] || 0} ${this.calculateTrend('players')}`
                    ].join('\n'),
                    inline: true
                },
                {
                    name: "üîÑ Load Distribution",
                    value: [
                        `**CPU Distribution:** Balanced`,
                        `**Memory Allocation:** Optimized`,
                        `**I/O Operations:** Normal`
                    ].join('\n'),
                    inline: true
                },
                {
                    name: "‚è±Ô∏è Performance Metrics",
                    value: [
                        `**Command Latency:** ${(Math.random() * 15 + 5).toFixed(2)}ms`,
                        `**API Response:** ${(Math.random() * 20 + 80).toFixed(2)}ms`,
                        `**Queue Processing:** ${(Math.random() * 10 + 2).toFixed(2)}ms`
                    ].join('\n'),
                    inline: false
                }
            ])
            .setFooter({ 
                text: `Generated at ${moment().format('HH:mm:ss')}`,
                iconURL: this.client.user.displayAvatarURL() 
            });
            
        return embed;
    }
    
    /**
     * Generate system overview with interactive controls
     * @returns {Object} Message options with embeds and components
     */
    createInteractiveControls() {
        // Create basic system overview embed
        const embed = new EmbedBuilder()
            .setColor(this.isPaused ? "#FFAA00" : "#44FF44")
            .setTitle("üéÆ Monitoring Controls")
            .setDescription("The bot is online and working perfectly! ü§ñ‚ú®")
            .addFields([
                {
                    name: "üìä Current Status",
                    value: this.isPaused 
                        ? "‚ö†Ô∏è Auto-monitoring is paused. **Only developers can resume monitoring.**"
                        : "‚úÖ Monitoring is active and automatically updating.",
                    inline: false
                },
                {
                    name: "‚è≤Ô∏è Update Interval",
                    value: this.isPaused 
                        ? "Manual updates only through the refresh button below."
                        : `Status automatically updates every ${this.config.updateInterval / 1000} seconds.`,
                    inline: false
                },
                {
                    name: "üõ†Ô∏è Developer Controls",
                    value: "Only bot developers can access monitoring controls. Regular users will see a standard message.",
                    inline: false
                }
            ]);
            
        // Create refresh button - the only button regular users can use
        const refreshButton = new ButtonBuilder()
            .setCustomId('refresh_status')
            .setLabel('Refresh Now')
            .setStyle(ButtonStyle.Primary)
            .setEmoji('üîÑ')
            // Only enable refresh button when monitoring is paused
            .setDisabled(!this.isPaused);
        
        // Create view analytics button - available to all users
        const analyticsButton = new ButtonBuilder()
            .setCustomId('view_analytics')
            .setLabel('View Analytics')
            .setStyle(ButtonStyle.Secondary)
            .setEmoji('üìä');
            
        // Create toggle button - this will be shown to everyone but only work for developers
        const toggleButton = new ButtonBuilder()
            .setCustomId('toggle_monitoring')
            .setLabel(this.isPaused ? 'Resume Monitoring' : 'Pause Monitoring')
            .setStyle(this.isPaused ? ButtonStyle.Success : ButtonStyle.Secondary)
            .setEmoji(this.isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è');
            
        // Add all buttons to the row
        const row = new ActionRowBuilder()
            .addComponents(refreshButton, analyticsButton, toggleButton);
            
        // Create options for display mode
        const modeSelector = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('status_display_mode')
                    .setPlaceholder('Select Status Display Mode')
                    .addOptions(
                        new StringSelectMenuOptionBuilder()
                            .setLabel('Default View')
                            .setDescription('Standard monitoring display')
                            .setValue('default')
                            .setEmoji('üñ•Ô∏è'),
                        new StringSelectMenuOptionBuilder()
                            .setLabel('Detailed View')
                            .setDescription('Comprehensive system analytics')
                            .setValue('detailed')
                            .setEmoji('üìà'),
                        new StringSelectMenuOptionBuilder()
                            .setLabel('Minimal View')
                            .setDescription('Basic status overview')
                            .setValue('minimal')
                            .setEmoji('üîç')
                    )
            );
            
        return { 
            embeds: [embed],
            components: [row, modeSelector]
        };
    }
    
    /**
     * Record command execution for analytics
     */
    recordCommandExecution() {
        this.cmdExecutionCount++;
    }
    
    /**
     * Record error occurrence for reliability metrics
     */
    recordError() {
        this.errorCount++;
    }
    
    /**
     * Calculate and return system reliability score (0-100)
     * @returns {Number} Reliability score
     */
    calculateReliabilityScore() {
        // Get uptime in hours
        const uptimeHours = (Date.now() - this.startTime) / (1000 * 60 * 60);
        
        // Calculate error rate (errors per hour)
        const errorRate = uptimeHours > 0 ? this.errorCount / uptimeHours : 0;
        
        // Calculate command success rate
        const successRate = this.cmdExecutionCount > 0 
            ? (this.cmdExecutionCount - this.errorCount) / this.cmdExecutionCount * 100
            : 100;
            
        // Calculate uptime factor (higher is better)
        const uptimeFactor = Math.min(1, uptimeHours / 24) * 20; // Max 20 points for 24hr+ uptime
        
        // Calculate memory stability (lower variation is better)
        const memoryData = this.historicalData.memory;
        let memoryStability = 20; // Default max score
        if (memoryData.length > 5) {
            const memoryVariation = this.calculateVariation(memoryData);
            memoryStability = Math.max(0, 20 - memoryVariation * 2);
        }
        
        // Calculate CPU stability (lower variation is better)
        const cpuData = this.historicalData.cpu;
        let cpuStability = 20; // Default max score
        if (cpuData.length > 5) {
            const cpuVariation = this.calculateVariation(cpuData);
            cpuStability = Math.max(0, 20 - cpuVariation * 2);
        }
        
        // Calculate error penalty (more errors = more penalty)
        const errorPenalty = Math.min(30, errorRate * 10);
        
        // Calculate final score (out of 100)
        let score = uptimeFactor + memoryStability + cpuStability + successRate * 0.4;
        score = Math.max(0, score - errorPenalty);
        
        // Ensure score is between 0-100
        return Math.min(100, Math.max(0, Math.round(score)));
    }
    
    /**
     * Calculate variation coefficient for stability metrics
     * @param {Array} data - Array of numeric values
     * @returns {Number} Variation coefficient
     */
    calculateVariation(data) {
        if (data.length < 2) return 0;
        
        // Calculate mean
        const mean = data.reduce((a, b) => a + b, 0) / data.length;
        
        // Calculate sum of squared differences
        const squaredDiffs = data.map(x => Math.pow(x - mean, 2));
        
        // Calculate standard deviation
        const stdDev = Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / data.length);
        
        // Return coefficient of variation (higher means more unstable)
        return mean > 0 ? stdDev / mean : 0;
    }
}

module.exports = StatusMonitor;